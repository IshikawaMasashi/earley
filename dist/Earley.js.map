{"version":3,"sources":["webpack://Earley/webpack/universalModuleDefinition","webpack://Earley/webpack/bootstrap","webpack://Earley/./src/Token.ts","webpack://Earley/./src/CharMatcher.ts","webpack://Earley/./src/Location.ts","webpack://Earley/./src/EarleyParser.ts","webpack://Earley/./src/index.ts","webpack://Earley/./src/TreeNode.ts","webpack://Earley/./src/EarleyItem.ts","webpack://Earley/./src/RuleParser.ts","webpack://Earley/./src/RuleSet.ts","webpack://Earley/./src/Tokenizer.ts","webpack://Earley/./src/NfaState.ts","webpack://Earley/./src/Nfa.ts","webpack://Earley/./src/DfaState.ts","webpack://Earley/./src/RangeMatcher.ts","webpack://Earley/./src/Rule.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","id","text","line","position","this","location","toString","Token","NextStateId","POST_NEWLINE","PRE_NEWLINE","DIGIT_CHAR","ANY_CHAR","mchar","match","ch","CharMatcher","ruleSet","dbg","errors","debug","tokenizer","createTokenizer","EPSILON","computeFirst","rules","first","getNonTerminal","getRegexFromTerminal","terminal","substr","length","isTerminal","symbol","undefined","isNonTerminal","parse","j","states","EarleyItem","setText","token","nextToken","push","printf","processedTo","predict","complete","scan","printState","EOF_TOKEN","evaluate","items","index","base","item","rule","symbols","pos","nonTerminal","addToState","_base","baseItems","prev","item_in","args","unshift","action","EarleyParser","default","RuleParser","NextId","str","nextRuleId","buildSet","RuleSet","addRule","nameOpt","_args","name2","finalize","parser","addToken","re","terminals","terminalsAdded","eatWhiteSpace","follow","joinExpr","check","size","ruleName","optimize","changed","replaceRule","innerExpr","newSymbols","splice","k","Rule","self","addFirst","ret","merge","destName","sourceName","computeFollow","f","Tokenizer","ignore","NfaState","listId","dfaCache","lineNumbers","IGNORE_TOKEN","finished","expr","nfa","parseAlternation","next","start","end","accept","eof","matchChar","peek","parseChar","parseRange","include","ranges","last","state","RangeMatcher","NFA","parseBasic","parseKleene","splitter","parseConcat","addState","nfaStateList","accepts","nfaState","lastList","nextState","dfaState","nfaStates","sort","a","b","DfaState","getLine","lineno","nextTokenInternal","rootDfa","startPosition","charMatcher","getNextStateId","processed","stack","pop","range","NextRuleId"],"mappings":"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","file":"Earley.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Earley\"] = factory();\n\telse\n\t\troot[\"Earley\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","import Location from './Location';\r\n\r\nexport class Token {\r\n  readonly location: Location;\r\n  /** @constructor */\r\n  constructor(\r\n    public id: string | {},\r\n    public text: string,\r\n    line: number,\r\n    position: number\r\n  ) {\r\n    this.location = new Location(line, position);\r\n  }\r\n  toString() {\r\n    return 'Token(' + this.text + ')';\r\n  }\r\n}\r\n","var NextStateId = 0;\r\n\r\nexport function getNextStateId() {\r\n  return NextStateId++;\r\n}\r\n\r\nexport var POST_NEWLINE = -1;\r\nexport var PRE_NEWLINE = -2;\r\nexport var DIGIT_CHAR = -3;\r\nexport var ANY_CHAR = -4;\r\n\r\n/** \r\n  When the match function is called, it will return true if the argument\r\n  matches a particular character.\r\n\r\n  @constructor \r\n */\r\nexport class CharMatcher {\r\n  public constructor(public mchar: number | string) {}\r\n\r\n  match(ch: number | string) {\r\n    //dbg.printf(\"Compare %s with %s\\n\", this.mchar, ch );\r\n    if (this.mchar == DIGIT_CHAR) {\r\n      return ch >= '0' && ch <= '9';\r\n    } else if (this.mchar == ANY_CHAR) {\r\n      return ch !== POST_NEWLINE && ch !== PRE_NEWLINE && ch != '\\n';\r\n    } else {\r\n      return ch == this.mchar;\r\n    }\r\n  }\r\n\r\n  toString() {\r\n    if (this.mchar == DIGIT_CHAR) {\r\n      return '\\\\d';\r\n    } else {\r\n      return this.mchar;\r\n    }\r\n  }\r\n}\r\n","/**\r\n  Represents a location in the source file. (The name \"location\" cannot be used\r\n  because it has a special meaning in browsers.) This is used throughout the\r\n  compiler to map program statements to token positions.\r\n */\r\n\r\nexport default class Location {\r\n  /**\r\n   *\r\n   * @param line\r\n   * @param position\r\n   */\r\n  constructor(readonly line: number, readonly position: number) {}\r\n  toString() {\r\n    const line = this.line;\r\n    const position = this.position;\r\n    return `${line + 1}:${position + 1}`;\r\n  }\r\n}\r\n","// import { dbg } from \"../qbasic/qb\";\r\nimport { Tokenizer } from './Tokenizer';\r\nimport { RuleSet } from './RuleSet';\r\nimport { EarleyItem } from './EarleyItem';\r\nimport Location from './Location';\r\nimport { Rule } from './Rule';\r\nimport { Token } from './Token';\r\nimport IDebugConsole from './IDebugConsole';\r\n/**\r\n  The Earley parser is like the proverbial tortoise. Its simplicity lets slowly\r\n  but surely it chug through any grammar you throw its way.\r\n\r\n  @constructor\r\n */\r\nexport class EarleyParser {\r\n  tokenizer: Tokenizer;\r\n  rules: { [key: string]: Rule[] };\r\n  first: { [key: string]: { [key: string]: number } };\r\n  errors: string[] = [];\r\n\r\n  location?: Location;\r\n  //EPSILON: {\r\n  //    toString: () => string;\r\n  //};\r\n  EPSILON: string;\r\n  debug = false; //true;\r\n  // dbg: IDebugConsole;\r\n  constructor(ruleSet: RuleSet, readonly dbg: IDebugConsole) {\r\n    // Map from rule name to NFA.\r\n    this.tokenizer = ruleSet.createTokenizer(dbg);\r\n    this.EPSILON = ruleSet.EPSILON;\r\n\r\n    ruleSet.computeFirst();\r\n\r\n    this.rules = ruleSet.rules;\r\n    this.first = ruleSet.first;\r\n\r\n    //this.debug = true;\r\n  }\r\n\r\n  getNonTerminal(name: string) {\r\n    return this.rules[name];\r\n  }\r\n\r\n  getRegexFromTerminal(terminal: string) {\r\n    return terminal.substr(1, terminal.length - 2);\r\n  }\r\n\r\n  isTerminal(symbol: string) {\r\n    return symbol !== undefined && symbol[0] == \"'\";\r\n  }\r\n\r\n  isNonTerminal(symbol: string) {\r\n    return symbol !== undefined && symbol[0] != \"'\";\r\n  }\r\n\r\n  parse(text: string) {\r\n    const dbg = this.dbg;\r\n    var states = [[new EarleyItem(this.rules['_start'][0], 0, 0)]];\r\n\r\n    var line = 0;\r\n    var position = 0;\r\n    var j;\r\n    this.tokenizer.setText(text);\r\n\r\n    this.errors = [];\r\n\r\n    for (var i = 0; ; i++) {\r\n      var token = this.tokenizer.nextToken(line, position);\r\n      if (token === null) {\r\n        this.errors.push(`Bad token at ${line}:${position}\\n`);\r\n        dbg.printf('Bad token!\\n');\r\n        return null;\r\n      } else if (this.debug) {\r\n        dbg.printf('Got token %s at %s\\n', token, token.location);\r\n      }\r\n      this.location = token.location;\r\n\r\n      states.push([]);\r\n      var processedTo = 0;\r\n      while (processedTo < states[i].length) {\r\n        // remain calm\r\n        this.predict(states[i], processedTo, i, token);\r\n        this.complete(states, i, processedTo, i);\r\n        processedTo++;\r\n      }\r\n\r\n      this.scan(states, i, token);\r\n\r\n      if (states[i].length === 0) {\r\n        this.errors.push(`Syntax error at ${this.location}: ${token}`);\r\n        for (j = 0; j < states[i - 1].length; j++) {\r\n          this.errors.push(`    ${states[i - 1][j]}\\n`);\r\n        }\r\n        break;\r\n      }\r\n\r\n      if (this.debug) {\r\n        this.printState(states, i);\r\n      }\r\n\r\n      line = token.location.line;\r\n      position = token.location.position + token.text.length;\r\n\r\n      if (token.id === this.tokenizer.EOF_TOKEN) {\r\n        //dbg.printf(\"Reached end of input.\\n\");\r\n        i++;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (this.debug) {\r\n      this.printState(states, i);\r\n    }\r\n    if (states[i].length) {\r\n      return this.evaluate(states[i][0]);\r\n    }\r\n\r\n    this.errors.push(`Syntax error at ${this.location}`);\r\n    for (j = 0; j < states[i - 1].length; j++) {\r\n      this.errors.push(`    ${states[i - 1][j]}\\n`);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  predict(items: EarleyItem[], index: number, base: number, token: Token) {\r\n    var item = items[index];\r\n    if (this.isNonTerminal(item.rule.symbols[item.pos])) {\r\n      var nonTerminal = this.getNonTerminal(item.rule.symbols[item.pos]);\r\n      for (var i = 0; i < nonTerminal.length; i++) {\r\n        var rule = nonTerminal[i];\r\n        if (\r\n          rule.symbols.length === 0 ||\r\n          rule.symbols[0][0] === \"'\" ||\r\n          this.first[rule.symbols[0]][<string>token.id] ||\r\n          this.first[rule.symbols[0]][this.EPSILON]\r\n        ) {\r\n          this.addToState(items, rule, 0, base, undefined, undefined);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  complete(states: EarleyItem[][], i: number, index: number, _base: number) {\r\n    var item = states[i][index];\r\n    if (item.pos == item.rule.symbols.length) {\r\n      var baseItems = states[item.base];\r\n      for (var j = 0; j < baseItems.length; j++) {\r\n        if (baseItems[j].rule.symbols[baseItems[j].pos] == item.rule.name) {\r\n          this.addToState(\r\n            states[i],\r\n            baseItems[j].rule,\r\n            baseItems[j].pos + 1,\r\n            baseItems[j].base,\r\n            item,\r\n            baseItems[j]\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  scan(states: EarleyItem[][], i: number, token: Token) {\r\n    var items = states[i];\r\n    for (var j = 0; j < items.length; j++) {\r\n      if (items[j].rule.symbols[items[j].pos] == token.id) {\r\n        states[i + 1].push(\r\n          new EarleyItem(\r\n            items[j].rule,\r\n            items[j].pos + 1,\r\n            items[j].base,\r\n            token,\r\n            items[j],\r\n            this.location\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  addToState(\r\n    items: EarleyItem[],\r\n    rule: Rule,\r\n    pos: number,\r\n    base: number,\r\n    token?: Token | EarleyItem,\r\n    prev?: EarleyItem\r\n  ) {\r\n    for (var i = 0; i < items.length; i++) {\r\n      if (\r\n        items[i].rule === rule &&\r\n        items[i].pos === pos &&\r\n        items[i].base === base\r\n      ) {\r\n        return;\r\n      }\r\n    }\r\n    items.push(new EarleyItem(rule, pos, base, token, prev, this.location));\r\n  }\r\n\r\n  printState(states: EarleyItem[][], index: number) {\r\n    const dbg = this.dbg;\r\n\r\n    if (!this.debug) {\r\n      return;\r\n    }\r\n    var items = states[index];\r\n    dbg.printf('State [%d]\\n', index);\r\n    for (var i = 0; i < items.length; i++) {\r\n      dbg.printf('%s\\n', items[i]);\r\n    }\r\n    dbg.printf('\\n');\r\n  }\r\n\r\n  // ----------------------------------------------------------------------\r\n  // Given an earley item, reconstruct the dervation and invoke any associated\r\n  // actions.\r\n  // ----------------------------------------------------------------------\r\n  evaluate(item_in?: EarleyItem) {\r\n    if (!item_in) {\r\n      return null;\r\n    }\r\n\r\n    var args: any[] = [];\r\n    var item: EarleyItem | undefined = item_in;\r\n    var location = item_in.location;\r\n\r\n    while (item) {\r\n      if (item.token instanceof Token) {\r\n        args.unshift(item.token.text);\r\n      } else if (item.token) {\r\n        args.unshift(this.evaluate(item.token));\r\n      }\r\n      location = item.location;\r\n      item = item.prev;\r\n    }\r\n\r\n    var result;\r\n\r\n    if (item_in.rule.action) {\r\n      result = item_in.rule.action(args, location!);\r\n    } else {\r\n      result = args[0];\r\n    }\r\n    return result;\r\n  }\r\n}\r\n","// export { default as VirtualList } from \"./components/VirtualList\";\n// export { ItemStyle } from \"./components/VirtualList\";\n// export { ALIGNMENT } from \"./components/constants\";\n\nexport { default as Location } from './Location';\nexport { default as TreeNode } from './TreeNode';\nexport { EarleyParser as default } from './EarleyParser';\nexport { RuleParser } from './RuleParser';\n","import Location from './Location';\r\n\r\nexport default abstract class TreeNode {\r\n  constructor(readonly location: Location) {}\r\n}\r\n","import Location from './Location';\r\nimport { Rule } from './Rule';\r\nimport { Token } from './Token';\r\n\r\nvar NextId = 0;\r\n/** @constructor */\r\nexport class EarleyItem {\r\n  public id = NextId++;\r\n  constructor(\r\n    public rule: Rule,\r\n    public pos: number,\r\n    public base: number,\r\n    public token?: Token | EarleyItem,\r\n    public prev?: EarleyItem,\r\n    public location?: Location\r\n  ) {}\r\n\r\n  toString() {\r\n    var str = '[' + this.id + '] ' + this.rule.name + ':';\r\n    for (var i = 0; i < this.rule.symbols.length; i++) {\r\n      if (i == this.pos) {\r\n        str += ' .';\r\n      }\r\n      str += ' ' + this.rule.symbols[i];\r\n    }\r\n\r\n    if (i == this.pos) {\r\n      str += ' .';\r\n    }\r\n    str += ', ' + this.base;\r\n    if (this.token instanceof Token) {\r\n      str += ', token=' + this.token.text;\r\n    } else if (this.token) {\r\n      str += ', rule=' + this.token.rule;\r\n    }\r\n    if (this.prev) {\r\n      str += ', prev=' + this.prev.id;\r\n    }\r\n    return str;\r\n  }\r\n}\r\n","import { RuleSet } from './RuleSet';\r\nimport { EarleyParser } from './EarleyParser';\r\nimport IDebugConsole from './IDebugConsole';\r\n\r\n// --------------------------------------------------------------------------\r\n// The ruleparser uses the parser to parse your rules from a string\r\n// into a RuleSet. It extends the grammar to handle *, +, ?, and | operators\r\n// in the grammar.\r\n// --------------------------------------------------------------------------\r\nexport class RuleParser {\r\n  // a unique number to let us make up rule names.\r\n  nextRuleId = 0;\r\n\r\n  // The buildset is the rules that we are building.\r\n  buildSet = new RuleSet();\r\n\r\n  action?: () => void;\r\n  parser: EarleyParser;\r\n\r\n  /**\r\n   * @constructor\r\n   */\r\n  constructor(dbg: IDebugConsole) {\r\n    // The rules are the grammar of the rules themselves.\r\n    const rules = new RuleSet();\r\n\r\n    // Lets us access this from local functions inside this function.\r\n    // var self = this;\r\n\r\n    rules.addRule('start', ['rule']);\r\n    rules.addRule('identifier', [\"'[A-Za-z0-9_]+'\"]);\r\n    rules.addRule('terminal', [\"''([^'\\\\\\\\]|\\\\\\\\.)*''\"]);\r\n    rules.addRule('expr', ['or_expr']);\r\n    rules.addRule(\r\n      'rule',\r\n      ['identifier', \"':'\", 'expr'],\r\n      (args: [string, string, string[]]) => {\r\n        this.buildSet.addRule(args[0], args[2], this.action);\r\n        return args[0];\r\n      }\r\n    );\r\n    rules.addRule('rule', ['identifier', \"':'\"], (args: string[]) => {\r\n      this.buildSet.addRule(args[0], [], this.action);\r\n      return args[0];\r\n    });\r\n    rules.addRule(\r\n      'or_expr',\r\n      ['or_expr', \"'\\\\|'\", 'cat_expr'],\r\n      (args: [string[], string, string[]]) => {\r\n        // Implement the or operator by making two new rules.\r\n        const name = '_' + this.nextRuleId++;\r\n        this.buildSet.addRule(name, args[0]);\r\n        this.buildSet.addRule(name, args[2]);\r\n        return [name];\r\n      }\r\n    );\r\n    rules.addRule('or_expr', ['cat_expr']);\r\n    rules.addRule(\r\n      'cat_expr',\r\n      ['cat_expr', 'list_expr'],\r\n      (args: [string[], string]) => {\r\n        args[0].push(args[1]);\r\n        return args[0];\r\n      }\r\n    );\r\n    rules.addRule('cat_expr', ['list_expr'], (args: string[]) => [args[0]]);\r\n\r\n    rules.addRule('list_expr', ['kleene_expr']);\r\n    rules.addRule(\r\n      'list_expr',\r\n      [\"'\\\\['\", 'kleene_expr', \"','\", 'kleene_expr', \"'\\\\]'\"],\r\n      (args: string[]) => {\r\n        var nameOpt = '_' + this.nextRuleId++;\r\n        var name = '_' + this.nextRuleId++;\r\n\r\n        this.buildSet.addRule(nameOpt, [name]);\r\n\r\n        this.buildSet.addRule(nameOpt, [], (_args: string[]) => [] as string[]);\r\n\r\n        this.buildSet.addRule(name, [args[1]], (args: string[]) => args); // list of one element.)\r\n\r\n        this.buildSet.addRule(\r\n          name,\r\n          [name, args[3], args[1]],\r\n          (args: [string[], string, string]) => {\r\n            // join the lists and return the result.\r\n            args[0].push(args[2]);\r\n            return args[0];\r\n          }\r\n        );\r\n\r\n        return nameOpt;\r\n      }\r\n    );\r\n\r\n    rules.addRule(\r\n      'kleene_expr',\r\n      ['basic_expr', \"'[\\\\+\\\\*\\\\?]'\"],\r\n      (args: string[]) => {\r\n        var name = '_' + this.nextRuleId++;\r\n\r\n        // Simulates kleene-star operations by adding more rules.\r\n        if (args[1] == '*') {\r\n          this.buildSet.addRule(\r\n            name,\r\n            [name, args[0]],\r\n            (args: [string[], string]) => {\r\n              args[0].push(args[1]);\r\n              return args[0];\r\n            }\r\n          );\r\n          this.buildSet.addRule(name, [], (_args: string[]) => [] as string[]);\r\n        } else if (args[1] == '?') {\r\n          this.buildSet.addRule(name, [args[0]]);\r\n          this.buildSet.addRule(name, [], (args: string[]) => null as unknown);\r\n        } else if (args[1] == '+') {\r\n          var name2 = '_' + this.nextRuleId++;\r\n          this.buildSet.addRule(name, [name2, args[0]]);\r\n          this.buildSet.addRule(name2, [name2, args[0]]);\r\n          this.buildSet.addRule(name2, []);\r\n        }\r\n\r\n        return name;\r\n      }\r\n    );\r\n    rules.addRule('kleene_expr', ['basic_expr']);\r\n    rules.addRule('basic_expr', ['identifier']);\r\n    rules.addRule('basic_expr', [\"'\\\\('\", 'expr', \"'\\\\)'\"], (args: any) => {\r\n      const name = '_' + this.nextRuleId++;\r\n      this.buildSet.addRule(name, args[1]);\r\n      return name;\r\n    });\r\n\r\n    rules.addRule('basic_expr', ['terminal']);\r\n\r\n    rules.finalize();\r\n    //dbg.printf(\"%s\", rules);\r\n\r\n    this.parser = new EarleyParser(rules, dbg);\r\n  }\r\n\r\n  // ----------------------------------------------------------------------\r\n  // Add a token to the rules. See RuleSet.addToken().\r\n  // ----------------------------------------------------------------------\r\n  addToken(name: string, re: string) {\r\n    this.buildSet.addToken(name, re);\r\n  }\r\n\r\n  // ----------------------------------------------------------------------\r\n  // Add a rule to the grammar. The rule will be parsed and can include\r\n  // regular-expression-like syntax.\r\n  // ----------------------------------------------------------------------\r\n  addRule(str: string, action?: any) {\r\n    this.action = action;\r\n    this.parser.parse(str);\r\n  }\r\n}\r\n","import { Tokenizer } from './Tokenizer';\r\nimport { Rule } from './Rule';\r\nimport IDebugConsole from './IDebugConsole';\r\n\r\nexport class RuleSet {\r\n  // Each entry is an array of rules that have the same name.\r\n  rules: { [key: string]: Rule[] } = {};\r\n  // list of terminals in the grammar, from highest priority to lowest.\r\n  terminals: string[] = [];\r\n  // Keep track of which terminals have been added already.\r\n  terminalsAdded: any = {};\r\n  // map from rule name to map of symbols of FIRST set.\r\n  first: { [key: string]: { [key: string]: number } } = {};\r\n  // Whitespace can be significant in some languages. For now, we ignore it.\r\n  eatWhiteSpace = true;\r\n  joinExpr: string;\r\n  // should be calculated later to be something not in the grammar.\r\n  EOF_TOKEN = \"'!EOF'\";\r\n\r\n  follow: { [key: string]: { [key: string]: number } } = {};\r\n  // ----------------------------------------------------------------------------\r\n  // Construct a ruleset object.\r\n  // ----------------------------------------------------------------------------\r\n  /** @constructor */\r\n  constructor() {\r\n    if (this.eatWhiteSpace) {\r\n      this.joinExpr = ' *';\r\n    } else {\r\n      this.joinExpr = '';\r\n    }\r\n    this.addRule('_start', ['start', this.EOF_TOKEN]);\r\n  }\r\n  // A constant representing nothing in the FIRST set.\r\n  //EPSILON = {\r\n  //    toString: function () {\r\n  //        return \"EPSILON\";\r\n  //    }\r\n  //};\r\n\r\n  EPSILON = 'EPSILON';\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Return string representation for debugging.\r\n  // ------------------------------------------------------------------------\r\n  toString() {\r\n    var str = '';\r\n    for (var name in this.rules) {\r\n      var rules = this.rules[name];\r\n      for (var i = 0; i < rules.length; i++) {\r\n        str += rules[i].toString() + '\\n';\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Verify consistency of the rules.\r\n  //\r\n  // errors - an array. Text describing the errors will be added to the end of this array.\r\n  //\r\n  // Returns: Number of errors found.\r\n  // ------------------------------------------------------------------------\r\n  check(errors: string[]) {\r\n    var size = errors.length;\r\n\r\n    // for each rule name,\r\n    for (var ruleName in this.rules) {\r\n      // for each rule by that name,\r\n      var rules = this.rules[ruleName];\r\n      for (var i = 0; i < rules.length; i++) {\r\n        var rule = rules[i];\r\n        for (var j = 0; j < rule.symbols.length; j++) {\r\n          var symbol = rule.symbols[j];\r\n          if (symbol.length === 0) {\r\n            errors.push(\r\n              \"Error: Rule '\" +\r\n                ruleName +\r\n                \"' contains a zero length symbol: \" +\r\n                symbol\r\n            );\r\n            // Verify that all non-terminals in the rule exist.\r\n          } else if (symbol[0] != \"'\") {\r\n            if (this.rules[symbol] === undefined) {\r\n              errors.push(\r\n                \"Error: Rule'\" +\r\n                  ruleName +\r\n                  \"' contains an undefined symbol: \" +\r\n                  symbol\r\n              );\r\n            }\r\n            // 2. Verify that all terminals are valid regular expressions.\r\n          } else {\r\n            // not easily done....\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return errors.length - size;\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Transform the grammar to try to reduce the number of rules.\r\n  // ------------------------------------------------------------------------\r\n  optimize() {\r\n    var changed = 1;\r\n    // loop until no change.\r\n    while (changed) {\r\n      changed = 0;\r\n\r\n      // for each rule name,\r\n      for (var name in this.rules) {\r\n        var rules = this.rules[name];\r\n\r\n        // inline the rule if it has no alternatives, one symbol, and\r\n        // no associated actions.\r\n        if (\r\n          rules.length == 1 &&\r\n          rules[0].name != '_start' &&\r\n          !rules[0].action\r\n        ) {\r\n          this.replaceRule(rules[0].name, rules[0].symbols);\r\n          changed |= 1;\r\n        }\r\n      }\r\n\r\n      //dbg.printf(\"Iteration---------------------------\\n\");\r\n      //dbg.print(this.toString());\r\n    }\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Remove quotes from a string.\r\n  // ------------------------------------------------------------------------\r\n  innerExpr(symbol: string) {\r\n    return symbol.substr(1, symbol.length - 2);\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Delete the rule, and replace all references to the rule with the\r\n  // given symbols.\r\n  // ------------------------------------------------------------------------\r\n  replaceRule(name: string, newSymbols: string[]) {\r\n    delete this.rules[name];\r\n    for (var ruleName in this.rules) {\r\n      var rules = this.rules[ruleName];\r\n      for (var i = 0; i < rules.length; i++) {\r\n        for (var j = 0; j < rules[i].symbols.length; j++) {\r\n          if (rules[i].symbols[j] == name) {\r\n            rules[i].symbols.splice(j, 1);\r\n            for (var k = 0; k < newSymbols.length; k++) {\r\n              rules[i].symbols.splice(j + k, 0, newSymbols[k]);\r\n            }\r\n            j += newSymbols.length - 1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Add the rule to the set.\r\n  // ------------------------------------------------------------------------\r\n  addRule(name: string, symbols: string[], action?: any) {\r\n    if (this.rules[name] === undefined) {\r\n      this.rules[name] = [];\r\n    }\r\n\r\n    this.rules[name].push(new Rule(name, symbols, action));\r\n    for (var i = 0; i < symbols.length; i++) {\r\n      if (\r\n        symbols.length > 0 &&\r\n        symbols[i][0] == \"'\" &&\r\n        !this.terminalsAdded[symbols[i]]\r\n      ) {\r\n        this.terminalsAdded[symbols[i]] = 1;\r\n        this.terminals.push(symbols[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Add a token. This simply creates a new rule.\r\n  // ------------------------------------------------------------------------\r\n  addToken(name: string, re: string) {\r\n    this.addRule(name, [\"'\" + re + \"'\"]);\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Compute rules that are nullable (non-terminal leads to nothing)\r\n  // ------------------------------------------------------------------------\r\n  computeFirst() {\r\n    this.first = {};\r\n    var name;\r\n    for (name in this.rules) {\r\n      this.first[name] = {};\r\n    }\r\n\r\n    var changed = true;\r\n    var self = this;\r\n\r\n    function addFirst(name: string, token: string) {\r\n      var ret = !(token in self.first[name]);\r\n      self.first[name][token] = 1;\r\n      return ret;\r\n    }\r\n\r\n    function merge(destName: string, sourceName: string) {\r\n      var ret = false; //0;\r\n      for (var token in self.first[sourceName]) {\r\n        //ret |= addFirst(destName, token);\r\n        ret = ret || addFirst(destName, token);\r\n      }\r\n      return ret;\r\n    }\r\n\r\n    // loop until no change.\r\n    while (changed) {\r\n      changed = false;\r\n\r\n      // for each rule name,\r\n      for (name in this.rules) {\r\n        var rules = this.rules[name];\r\n        // for each RHS of the rule,\r\n        for (var i = 0; i < rules.length; i++) {\r\n          // If the rule has no symbols,\r\n          if (rules[i].symbols.length === 0) {\r\n            // add EPSILON to first set\r\n            changed = changed || addFirst(name, this.EPSILON);\r\n          }\r\n\r\n          // for each symbol of the rule,\r\n          for (var j = 0; j < rules[i].symbols.length; j++) {\r\n            // if it is a terminal\r\n            if (rules[i].symbols[j][0] == \"'\") {\r\n              changed = changed || addFirst(name, rules[i].symbols[j]);\r\n              break;\r\n\r\n              // if it's a terminal,\r\n            } else {\r\n              changed = changed || merge(name, rules[i].symbols[j]);\r\n\r\n              if (this.first[rules[i].symbols[j]][this.EPSILON] !== 1) {\r\n                // continue only if it contains the epsilon\r\n                // symbol.\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Compute follow set of all non-terminals.\r\n  // ------------------------------------------------------------------------\r\n  computeFollow() {\r\n    // var name;\r\n    this.follow = {};\r\n    for (let name in this.rules) {\r\n      this.follow[name] = {};\r\n    }\r\n\r\n    var changed = true; //1;\r\n\r\n    while (changed) {\r\n      changed = false; //0;\r\n      var f;\r\n      for (let name in this.rules) {\r\n        var rules = this.rules[name];\r\n        for (var i = 0; i < rules.length; i++) {\r\n          var rule = rules[i];\r\n          for (var j = 0; j < rule.symbols.length; j++) {\r\n            if (rule.symbols[j][0] === \"'\") {\r\n              continue;\r\n            }\r\n            var follow = this.follow[rule.symbols[j]];\r\n\r\n            if (j == rule.symbols.length - 1) {\r\n              if (rule.symbols[j][0] != \"'\" && rule.symbols[j] != name) {\r\n                for (f in this.follow[name]) {\r\n                  if (f !== this.EPSILON) {\r\n                    //dbg.printf(\"%s follows %s cause it's last of %s\\n\", f, rule.symbols[j], name );\r\n                    //changed |= follow[f] === undefined;\r\n                    changed = changed || follow[f] === undefined;\r\n                    follow[f] = 1;\r\n                  }\r\n                }\r\n              }\r\n            } else if (\r\n              rule.symbols[j + 1][0] == \"'\" ||\r\n              rule.symbols[j + 1] === this.EOF_TOKEN\r\n            ) {\r\n              //changed |= follow[rule.symbols[j + 1]] === undefined;\r\n              changed = changed || follow[rule.symbols[j + 1]] === undefined;\r\n              follow[rule.symbols[j + 1]] = 1;\r\n              //dbg.printf(\"%s follows %s\\n\", rule.symbols[j+1],\r\n              //    rule.symbols[j]);\r\n            } else {\r\n              for (f in this.first[rule.symbols[j + 1]]) {\r\n                if (f !== this.EPSILON) {\r\n                  //dbg.printf(\"%s follows %s via %s\\n\",\r\n                  //    f, name, rule.symbols[j+1] );\r\n                  //changed |= follow[f] === undefined;\r\n                  changed = changed || follow[f] === undefined;\r\n                  follow[f] = 1;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  finalize() {\r\n    this.optimize();\r\n    this.computeFirst();\r\n    this.computeFollow();\r\n  }\r\n\r\n  createTokenizer(dbg: IDebugConsole) {\r\n    var tokenizer = new Tokenizer(dbg);\r\n    tokenizer.ignore('[ \\t\\r\\u001a]+');\r\n\r\n    for (var i = 0; i < this.terminals.length; i++) {\r\n      //dbg.printf(\"Add token %s='%s'\\n\",\r\n      //    this.terminals[i],\r\n      //    this.innerExpr( this.terminals[i] ) );\r\n      tokenizer.addToken(this.terminals[i], this.innerExpr(this.terminals[i]));\r\n    }\r\n\r\n    tokenizer.EOF_TOKEN = this.EOF_TOKEN;\r\n    return tokenizer;\r\n  }\r\n}\r\n","import { NfaState } from './NfaState';\r\nimport { NFA } from './Nfa';\r\nimport { DfaState } from './DfaState';\r\nimport {\r\n  POST_NEWLINE,\r\n  PRE_NEWLINE,\r\n  DIGIT_CHAR,\r\n  ANY_CHAR,\r\n  CharMatcher\r\n} from './CharMatcher';\r\nimport { RangeMatcher } from './RangeMatcher';\r\nimport { Token } from './Token';\r\nimport IDebugConsole from './IDebugConsole';\r\n\r\n/** @constructor */\r\nexport class Tokenizer {\r\n  root = new NfaState();\r\n  expr?: string; // = null;\r\n  index = 0;\r\n  listId = 1;\r\n  dfaCache: { [key: string]: DfaState } = {};\r\n\r\n  // text to tokenize.\r\n  text = '';\r\n\r\n  // for each line, the character position of that line in the text.\r\n  lineNumbers: number[] = [];\r\n\r\n  // users can redefine these if they want.\r\n  EOF_TOKEN = {};\r\n  IGNORE_TOKEN = {};\r\n\r\n  // check this to determine if we have reached the end of the text.\r\n  finished = true;\r\n\r\n  rootDfa?: DfaState;\r\n\r\n  //   dbg: IDebugConsole;\r\n  constructor(readonly dbg: IDebugConsole) {}\r\n\r\n  addToken(id: string | {}, expr: string) {\r\n    this.expr = expr;\r\n    this.index = 0;\r\n    var nfa = this.parseAlternation();\r\n    this.root.next.push(nfa.start);\r\n    nfa.end.accept = id;\r\n  }\r\n\r\n  ignore(expr: string) {\r\n    this.addToken(this.IGNORE_TOKEN, expr);\r\n  }\r\n\r\n  eof() {\r\n    return this.index == this.expr!.length;\r\n  }\r\n\r\n  matchChar(ch: string) {\r\n    if (this.expr![this.index] == ch) {\r\n      this.index++;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  peek(ch: string) {\r\n    return this.expr![this.index] == ch;\r\n  }\r\n\r\n  parseChar() {\r\n    if (this.matchChar('\\\\')) {\r\n      if (this.matchChar('n')) {\r\n        return '\\n';\r\n      } else if (this.matchChar('r')) {\r\n        return '\\r';\r\n      } else if (this.matchChar('t')) {\r\n        return '\\t';\r\n      } else if (this.matchChar('d')) {\r\n        return DIGIT_CHAR;\r\n      } else {\r\n        return this.expr![this.index++];\r\n      }\r\n    } else if (this.matchChar('.')) {\r\n      return ANY_CHAR;\r\n    } else if (this.matchChar('$')) {\r\n      return PRE_NEWLINE;\r\n    } else if (this.matchChar('^')) {\r\n      return POST_NEWLINE;\r\n    } else {\r\n      return this.expr![this.index++];\r\n    }\r\n  }\r\n\r\n  parseRange() {\r\n    var include = true;\r\n    var ranges: any[] = [];\r\n\r\n    while (!this.eof() && !this.peek(']')) {\r\n      if (this.matchChar('^')) {\r\n        include = false;\r\n      }\r\n      var first = this.parseChar();\r\n      var last = first;\r\n      if (this.matchChar('-')) {\r\n        last = this.parseChar();\r\n      }\r\n\r\n      if (first == DIGIT_CHAR) {\r\n        first = '0';\r\n        last = '9';\r\n      }\r\n\r\n      //dbg.printf(\"Pushing range %s..%s\\n\", first, last );\r\n      ranges.push([first, last]);\r\n    }\r\n\r\n    var state = new NfaState(<any>new RangeMatcher(ranges, include));\r\n    return new NFA(state, state);\r\n  }\r\n\r\n  parseBasic() {\r\n    var nfa;\r\n\r\n    if (this.matchChar('(')) {\r\n      nfa = this.parseAlternation();\r\n      if (!this.matchChar(')')) {\r\n        throw \"Expected ')'\";\r\n      }\r\n    } else if (this.matchChar('[')) {\r\n      //dbg.printf(\"Encountered RANGE!\\n\");\r\n      nfa = this.parseRange();\r\n      if (!this.matchChar(']')) {\r\n        throw \"Expected ']'\";\r\n      }\r\n    } else {\r\n      var state = new NfaState(new CharMatcher(this.parseChar()));\r\n      nfa = new NFA(state, state);\r\n    }\r\n\r\n    return nfa;\r\n  }\r\n\r\n  parseKleene() {\r\n    var nfa = this.parseBasic();\r\n    // var splitter;\r\n    if (this.matchChar('+')) {\r\n      let splitter = new NfaState();\r\n      nfa.end.next.push(splitter);\r\n      splitter.next.push(nfa.start);\r\n      nfa.end = splitter;\r\n    } else if (this.matchChar('*')) {\r\n      let splitter = new NfaState();\r\n      splitter.next.push(nfa.start);\r\n      nfa.end.next.push(splitter);\r\n      nfa.start = splitter;\r\n      nfa.end = splitter;\r\n    } else if (this.matchChar('?')) {\r\n      var start = new NfaState();\r\n      var end = new NfaState();\r\n      start.next.push(nfa.start);\r\n      start.next.push(end);\r\n      nfa.end.next.push(end);\r\n      nfa.start = start;\r\n      nfa.end = end;\r\n    }\r\n\r\n    return nfa;\r\n  }\r\n\r\n  parseConcat() {\r\n    var start = new NfaState();\r\n    var end = start;\r\n    for (;;) {\r\n      if (this.peek('|') || this.peek(')') || this.eof()) {\r\n        break;\r\n      }\r\n      var nfa = this.parseKleene();\r\n      end.next.push(nfa.start);\r\n      end = nfa.end;\r\n    }\r\n    return new NFA(start, end);\r\n  }\r\n\r\n  parseAlternation() {\r\n    var start = new NfaState();\r\n    var end = new NfaState();\r\n    do {\r\n      var nfa = this.parseConcat();\r\n      start.next.push(nfa.start);\r\n      nfa.end.next.push(end);\r\n    } while (this.matchChar('|'));\r\n\r\n    return new NFA(start, end);\r\n  }\r\n\r\n  addState(nfaStateList: NfaState[], accepts: string[], nfaState: NfaState) {\r\n    if (nfaState.lastList == this.listId) {\r\n      //dbg.printf(\"Skip adding nfa State [%d]\\n\", nfaState.id );\r\n      return;\r\n    }\r\n\r\n    //dbg.printf(\"Add NFA state [%d]\\n\", nfaState.id );\r\n    if (nfaState.accept !== undefined) {\r\n      accepts.push(<string>nfaState.accept);\r\n    }\r\n\r\n    nfaState.lastList = this.listId;\r\n    nfaStateList.push(nfaState);\r\n\r\n    if (nfaState.mchar === undefined) {\r\n      for (var i = 0; i < nfaState.next.length; i++) {\r\n        this.addState(nfaStateList, accepts, nfaState.next[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  nextState(dfaState: DfaState, ch: number | string) {\r\n    var nfaStateList: NfaState[] = [];\r\n    var accepts: string[] = [];\r\n    var i;\r\n    //dbg.printf(\"Transition from DFA[%d] on ch=%s\\n\", dfaState.id, ch );\r\n\r\n    this.listId++;\r\n\r\n    for (i = 0; i < dfaState.nfaStates.length; i++) {\r\n      var nfaState = dfaState.nfaStates[i];\r\n      if (nfaState.mchar !== undefined) {\r\n        if (nfaState.mchar.match(ch)) {\r\n          this.addState(nfaStateList, accepts, nfaState.next[0]);\r\n        } else if (ch == PRE_NEWLINE || ch == POST_NEWLINE) {\r\n          this.addState(nfaStateList, accepts, nfaState);\r\n        }\r\n      }\r\n    }\r\n\r\n    nfaStateList.sort(function(a, b) {\r\n      return a.id - b.id;\r\n    });\r\n\r\n    var key = '';\r\n    for (i = 0; i < nfaStateList.length; i++) {\r\n      key += nfaStateList[i].id + '.';\r\n    }\r\n\r\n    if (this.dfaCache[key] === undefined) {\r\n      dfaState = new DfaState();\r\n      //dbg.printf(\"Created DFA state [%d] accepts=%s\\n\", dfaState.id, accepts );\r\n      dfaState.nfaStates = nfaStateList;\r\n      dfaState.accepts = accepts;\r\n      this.dfaCache[key] = dfaState;\r\n    } else {\r\n      //dbg.printf(\"Returning cached DFA state [%d] accepts=%s\\n\",\r\n      //        this.dfaCache[key].id, this.dfaCache[key].accepts );\r\n    }\r\n\r\n    return this.dfaCache[key];\r\n  }\r\n\r\n  setText(text: string) {\r\n    this.text = text;\r\n    this.lineNumbers.length = 0;\r\n    this.lineNumbers.push(0);\r\n    this.finished = false;\r\n\r\n    for (var i = 0; i < this.text.length; i++) {\r\n      if (this.text[i] == '\\n') {\r\n        this.lineNumbers.push(i + 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  getLine(lineno: number) {\r\n    return this.text.substr(\r\n      this.lineNumbers[lineno],\r\n      this.lineNumbers[lineno + 1] - this.lineNumbers[lineno]\r\n    );\r\n  }\r\n\r\n  /**\r\n        Retrieve a list of tokens that match at a given position. The list is\r\n        returned sorted in order of length.\r\n\r\n        @param text Text to match.\r\n        @param line Line number to begin matching, starting from 0\r\n        @param position Character position on the line to begin matching.\r\n    */\r\n  nextTokenInternal(line: number, position: number) {\r\n    const dbg = this.dbg;\r\n    //var last = 0;\r\n    let last: string | number = 0;\r\n    var i;\r\n    var accept = null;\r\n\r\n    if (this.rootDfa === undefined) {\r\n      this.rootDfa = new DfaState();\r\n      this.addState(this.rootDfa.nfaStates, this.rootDfa.accepts, this.root);\r\n    }\r\n\r\n    var dfaState = this.rootDfa;\r\n\r\n    var startPosition = this.lineNumbers[line] + position;\r\n    //dbg.printf(\"Start match from %d:%d\\n\", line, position );\r\n\r\n    if (startPosition == this.text.length) {\r\n      this.finished = true;\r\n      return new Token(this.EOF_TOKEN, '!EOF', line, position);\r\n    }\r\n\r\n    if (startPosition > 0) {\r\n      last = this.text[startPosition - 1];\r\n    }\r\n\r\n    for (i = startPosition; i < this.text.length; i++) {\r\n      //dbg.printf(\"Enter DFA state %d\\n\", dfaState.id );\r\n      var ch: number | string = this.text[i];\r\n\r\n      if (ch === '\\n' && last != PRE_NEWLINE) {\r\n        ch = PRE_NEWLINE;\r\n        i--;\r\n      } else if (last === '\\n' || last === 0) {\r\n        ch = POST_NEWLINE;\r\n        i--;\r\n      }\r\n\r\n      if (last === '\\n') {\r\n        line++;\r\n      }\r\n      last = ch;\r\n\r\n      if (dfaState.next[ch] === undefined) {\r\n        dfaState.next[ch] = this.nextState(dfaState, ch);\r\n      }\r\n      dfaState = dfaState.next[ch];\r\n\r\n      if (dfaState.accepts.length) {\r\n        //dbg.printf(\"Would accept %s\\n\", dfaState.accepts[0] );\r\n        //dbg.printf(\"i:%d line:%d lineNumbers=%d\\n\",\r\n        //    i, line, this.lineNumbers[line] );\r\n        accept = new Token(\r\n          dfaState.accepts[0],\r\n          this.text.substr(startPosition, i - startPosition + 1),\r\n          line,\r\n          startPosition - this.lineNumbers[line]\r\n        );\r\n      }\r\n\r\n      if (dfaState.nfaStates.length === 0) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (accept) {\r\n      //dbg.printf(\"Returning match id=%s at %d:%d text=%s\\n\", accept.id,\r\n      //    accept.locus.line, accept.locus.position, accept.text );\r\n    } else if (0) {\r\n      dbg.printf(\"Bad token at '%s'\\n\", this.text.substr(startPosition, 10));\r\n      dbg.printf('ascii %d\\n', this.text.charCodeAt(startPosition));\r\n    }\r\n\r\n    return accept;\r\n  }\r\n\r\n  nextToken(line: number, position: number) {\r\n    for (;;) {\r\n      var token = this.nextTokenInternal(line, position);\r\n      if (token === null || token.id !== this.IGNORE_TOKEN) {\r\n        return token;\r\n      }\r\n      line = token.location.line;\r\n      position = token.location.position + token.text.length;\r\n    }\r\n  }\r\n}\r\n","import { CharMatcher, getNextStateId } from './CharMatcher';\r\n\r\nexport class NfaState {\r\n  mchar?: CharMatcher;\r\n  next: NfaState[] = [];\r\n  id = getNextStateId(); //NextStateId++;\r\n  lastList = 0;\r\n  accept: string | {} | undefined = undefined;\r\n  /** @constructor */\r\n  constructor(charMatcher?: CharMatcher) {\r\n    this.mchar = charMatcher;\r\n  }\r\n  toString() {\r\n    var str = '\\nState [' + this.id + '] ch=' + this.mchar + '\\n';\r\n    if (this.accept !== undefined) {\r\n      str += '    Accept ' + this.accept + '\\n';\r\n    }\r\n    for (var i = 0; i < this.next.length; i++) {\r\n      str +=\r\n        '    ch=' + this.next[i].mchar + ' goto [' + this.next[i].id + ']\\n';\r\n    }\r\n    return str;\r\n  }\r\n}\r\n","import { NfaState } from './NfaState';\r\n\r\nexport class NFA {\r\n  /** @constructor */\r\n  public constructor(public start: NfaState, public end: NfaState) {}\r\n\r\n  public toString() {\r\n    var processed: any = {};\r\n    var stack = [this.start];\r\n    var str = '';\r\n\r\n    while (stack.length > 0) {\r\n      var state = <any>stack.pop();\r\n      if (processed[state]) {\r\n        continue;\r\n      }\r\n      processed[state] = 1;\r\n\r\n      for (var i = 0; i < state.next.length; i++) {\r\n        stack.push(state.next[i]);\r\n      }\r\n      str += state.toString();\r\n    }\r\n    return str;\r\n  }\r\n}\r\n","import { getNextStateId } from './CharMatcher';\r\nimport { NfaState } from './NfaState';\r\n\r\n/** @constructor */\r\nexport class DfaState {\r\n  public nfaStates: NfaState[] = [];\r\n  public next: { [key: string]: DfaState } = {};\r\n  public accepts: string[] = [];\r\n  public id = getNextStateId(); //NextStateId++;\r\n  public constructor() {}\r\n}\r\n","/** \r\n  When the match function is called, it will return true if the argument\r\n  matches a particular character range.\r\n\r\n  */\r\nexport class RangeMatcher {\r\n  /**\r\n   *\r\n   * @constructor\r\n   * @param ranges\r\n   * @param include\r\n   */\r\n  public constructor(\r\n    public ranges: [number, number][],\r\n    public include: boolean\r\n  ) {\r\n    // list of [ start, end ]\r\n    // this.ranges = ranges;\r\n    // this.include = include; // boolean\r\n  }\r\n\r\n  match(ch: number) {\r\n    for (var i = 0; i < this.ranges.length; i++) {\r\n      var range = this.ranges[i];\r\n      if (ch >= range[0] && ch <= range[1]) {\r\n        return this.include;\r\n      }\r\n    }\r\n\r\n    return !this.include;\r\n  }\r\n\r\n  toString() {\r\n    var str = '[';\r\n    if (!this.include) {\r\n      str += '^';\r\n    }\r\n    for (var i = 0; i < this.ranges.length; i++) {\r\n      if (this.ranges[i][0] == this.ranges[i][1]) {\r\n        str += this.ranges[i][0];\r\n      } else {\r\n        str += this.ranges[i][0] + '-' + this.ranges[i][1];\r\n      }\r\n    }\r\n    return str + ']';\r\n  }\r\n}\r\n","import Location from './Location';\r\nimport TreeNode from './TreeNode';\r\n\r\nvar NextRuleId = 0;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Construct a rule object.\r\n// ----------------------------------------------------------------------------\r\n/** @constructor */\r\nexport class Rule {\r\n  readonly id = NextRuleId++;\r\n  constructor(\r\n    readonly name: string,\r\n    readonly symbols: string[],\r\n    readonly action?: (args: any, location: Location) => string | TreeNode\r\n  ) {\r\n    // this.id = NextRuleId++;\r\n    // Name of the rule.\r\n    // this.name = name;\r\n    // array of symbols. If the symbol begins with ' then it is a regular\r\n    // expression. Otherwise, it is the name of another rule. The array\r\n    // may not be null. For an empty rule, use a zero-length array.\r\n    // this.symbols = symbols;\r\n    // The action. May be undefined.\r\n    // this.action = action;\r\n  }\r\n\r\n  // ----------------------------------------------------------------------------\r\n  // Returns string representation of a rule for debugging.\r\n  // ----------------------------------------------------------------------------\r\n\r\n  public toString() {\r\n    let str = this.name + ':';\r\n\r\n    for (var i = 0; i < this.symbols.length; i++) {\r\n      str += ' ' + this.symbols[i];\r\n    }\r\n\r\n    if (0 && this.action) {\r\n      // this prints out the whole function which can be undesirable.\r\n      str += ' action=' + this.action;\r\n    }\r\n\r\n    return str;\r\n  }\r\n}\r\n"],"sourceRoot":""}